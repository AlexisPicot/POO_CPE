<script>
	import Code from '$lib/deck/code.svelte'

	import Gpt from '$lib/deck/gpt.svelte'
	import Slide from '$lib/deck/slide.svelte'
</script>

<Slide>
	<h3>Les objets et les classes</h3>
</Slide>
<Slide>
	<h3>√âvolution</h3>
	<h4>L'assembleur</h4>

	<p>Programmation dict√©e par le fonctionnement des processeurs</p>
	<ul>
		<li>Programme = succession d'instructions</li>
		<li>
			Organisation du programme et nature des instructions le plus proche possible de la fa√ßon dont
			le processeur les ex√©cute
			<ul>
				<li>Modification des donn√©es m√©moris√©es</li>
				<li>D√©placement des donn√©es d'un emplacement √† un autre</li>
				<li>Op√©rations arithm√©tiques et de logique √©l√©mentaires</li>
				<li>
					Programmation en langage ¬´ machine ¬ª
					<ul>
						<li>Exemple : ¬´ c = a + b ¬ª se programme</li>
						<li>
							<Code lines className="language-x86asm"
								>{`
						LD A, REG1
						LD B, REG2
						ADD REG3, REG1, REG2
						MV c, REG3`}</Code
							>
						</li>
					</ul>
				</li>
			</ul>
		</li>
	</ul>
</Slide>
<Slide>
	<h3>√âvolution</h3>
	<h4>Les langages proc√©duraux</h4>
	<p>Mise au point d'algorithmes plus complexes</p>

	<ul>
		<li>
			N√©cessit√© de simplifier la programmation
			<ul><li>Langages C, Cobol, etc.</li></ul>
		</li>
		<li>
			Le raisonnement reste n√©anmoins conditionn√© par la conception des traitements et leur
			succession
			<ul>
				<li>√âloign√© de la mani√®re humaine de poser et r√©soudre les probl√®mes</li>
				<li>Mal adapt√© √† des probl√®mes de plus en plus complexes</li>
			</ul>
		</li>
	</ul>
</Slide>

<Slide>
	<h3>√âvolution</h3>
	<h4>Les langages orient√©s objet</h4>
	<p>Lib√©rer la programmation des contraintes li√©es au fonctionnement des processeurs</p>

	<ul>
		<li>Rapprocher la programmation du mode cognitif de r√©solution des probl√®mes</li>
		<li>
			Mise au point d'un nouveau style de langage de programmation
			<ul>
				<li>Placer les entit√©s, objets ou acteurs du probl√®me √† la base de la conception</li>
				<li>√âtudier les traitements comme des interactions entre les entit√©s</li>
				<li>Penser aux donn√©es AVANT de penser aux traitements</li>
			</ul>
		</li>
	</ul>
</Slide>
<Slide>
	<h3>Les objets et les classes</h3>
	<h4>Qu'est ce qu'un objet ?</h4>
	<Gpt>
		Un objet est une instance d'une <strong class="text-red-400">classe</strong> qui contient √† la fois
		des informations et des actions sp√©cifiques √† une entit√©, comme une voiture ou un animal. Il combine
		les donn√©es (comme la couleur d'une voiture) et les actions (comme acc√©l√©rer) en une seule entit√©
		utilisable.
	</Gpt>
	<span>En fin de compte, c'est un peu une variable, de type structure, mais avec des m√©thodes</span
	>
</Slide>
<Slide>
	<h3>Les objets et les classes</h3>
	<h4>Qu'est ce qu'une classe ?</h4>
	<Gpt>
		En programmation orient√©e objet (POO), une classe est comme un plan ou un mod√®le pour cr√©er des
		objets. Prenons l'exemple d'une recette de cuisine : la classe serait semblable √† la recette
		elle-m√™me. Elle d√©crit les ingr√©dients n√©cessaires et les √©tapes √† suivre pour cr√©er un plat
		sp√©cifique. Une fois que vous avez la recette, vous pouvez cr√©er plusieurs plats diff√©rents en
		suivant les m√™mes instructions de la recette.
	</Gpt>
</Slide>
<Slide>
	<h3>Les objets et les classes</h3>
	<h4>Qu'est ce qu'une classe ?</h4>

	<ul>
		<li>
			Une classe est constitu√©e de descriptions de :
			<ul>
				<li>donn√©es : que l'on nomme <strong>attributs</strong></li>
				<li>proc√©dures et fonctions : que l'on nomme <strong>m√©thodes</strong></li>
			</ul>
		</li>
		<li>
			Une classe est uniquement un mod√®le de repr√©sentation d'objets
			<ul>
				<li>ayant m√™me structure (m√™me ensemble d'attributs)</li>
				<li>ayant m√™me comportement (m√™me ensemble de m√©thodes)</li>
			</ul>
		</li>
		<li>
			Les objets sont des repr√©sentations, on parle d'instances du mod√®le d√©fini dans les classes
			<ul>
				<li>une classe permet d'instancier (cr√©er) plusieurs objets</li>
				<li>en g√©n√©ral, un objet est instance d'une classe</li>
			</ul>
		</li>
	</ul>
</Slide>

<Slide>
	<h3>Les objets et les classes</h3>
	<h4>Qu'est ce que <span class="text-red-400">N'EST PAS</span> un objet ?</h4>
</Slide>
<Slide>
	<h3>Les objets et les classes</h3>
	<h4>Qu'est ce que <span class="text-red-400">N'EST PAS</span> un objet ?</h4>
	<div class="flex flex-row items-center">
		<pre>
            <code data-trim data-line-numbers={true} class="r-strech h-[650px]">
			{`
public static void main(String[] args) {
    int vitesseVoiture = 0; 
    accelerer(vitesseVoiture);
    freiner(vitesseVoiture);
    System.out.printf(
     "La vitesse de la voiture est : %d km/h\n", vitesseVoiture);
    }
	public void accelerer(int vitesse){
		vitesse += 10;
	}
	public void freiner(int vitesse){
		vitesse -= 10;
	}
}
`}</code
			></pre>
	</div>
</Slide>
<Slide>
	<h3>Les objets et les classes</h3>
	<h4>Qu'est ce qu'un objet ?</h4>
	<div class="flex flex-row items-center">
		<pre>
            <code data-trim data-line-numbers={true} class="language-java">
			{`
public class Main {
	public static void main(String[] args) {
		Voiture maVoiture = new Voiture(); // Cr√©ation d'un objet de type Voiture

		// Simulation des actions sur la voiture
		maVoiture.accelerer();
		maVoiture.freiner();

		// Affichage de la vitesse de la voiture
		System.out.printf(
				"La vitesse de la voiture est : %d km/h\n",
				maVoiture.vitesse);
	}
}

public class Voiture {
	public int vitesse; // La vitesse de la voiture

	// Constructeur
	public Voiture() {
		this.vitesse = 0; // La vitesse initiale est de 0
	}

	// M√©thode pour acc√©l√©rer la voiture
	public void accelerer() {
		// Impl√©mentation de l'acc√©l√©ration (par exemple, ajouter 10 √† la vitesse)
		this.vitesse += 10;
	}

	// M√©thode pour freiner la voiture
	public void freiner() {
		// Impl√©mentation du freinage (par exemple, soustraire 5 √† la vitesse)
		this.vitesse -= 5;
	}
}`}</code
			></pre>
	</div>
</Slide>
<Slide>
	<h3>√áa semble sans int√©r√™t</h3>
	<i>34 lignes pour √ßa ?</i>
	<div class="flex flex-row justify-center">
		<img
			alt="Pourquoi"
			class="object-cover text-center print:hidden h-[200px]"
			src="https://media1.tenor.com/m/s1wnF2DiWA0AAAAC/skeptical-futurama.gif"
		/>
	</div>
	<ul>
		<li>üò´ Le code est plus long</li>
		<li>üòï Le code est moins optimis√©</li>
		<li>üôÑ Il y a 50 fichiers √† modifier</li>
		<li>üôÉ Il faut plus r√©flechir</li>
	</ul>
</Slide>
<Slide>
	<h3>Les avanatges de la POO</h3>
	<ul>
		<li>On va pouvoir faire de l'encapsulation</li>
		<li>On va pouvoir faire de l'h√©ritage</li>
		<li>On va pouvoir faire du polymorphisme</li>
		<li>On va pouvoir faire de l'abstraction</li>
		<li>On va pouvoir faire de la modularit√©</li>
		<li>On va pouvoir faire de la r√©utilisabilit√©</li>
		<li>etc.</li>
	</ul>
</Slide>
<Slide>
	<h3>G√©n√©ralit√©s</h3>
	<h4>Les constructeurs</h4>
	<div class="r-fit-text">
		<p>
			Les constructeurs en Java sont des m√©thodes sp√©ciales utilis√©es pour initialiser les objets
			d'une classe. Voici quelques points cl√©s √† retenir :
		</p>
		<ul class="fragment">
			<li>
				<strong>Initialisation des objets</strong>: Les constructeurs sont utilis√©s pour initialiser
				les variables d'instance d'un objet lors de sa cr√©ation.
			</li>
			<li class="fragment">
				<strong>Nom de la classe</strong>: Le nom du constructeur doit correspondre exactement au
				nom de la classe dans laquelle il est d√©fini.
			</li>
			<li class="fragment">
				<strong>Pas de type de retour explicite</strong>: Contrairement aux autres m√©thodes, les
				constructeurs n'ont pas de type de retour explicite, m√™me pas <code>void</code>.
			</li>
			<li class="fragment">
				<strong>Surcharges</strong>: Vous pouvez d√©finir plusieurs constructeurs dans une classe en
				utilisant la surcharge, ce qui permet de cr√©er des objets de diff√©rentes mani√®res.
			</li>
			<li class="fragment">
				<strong>Appel explicite du constructeur parent</strong>: Si une classe h√©rite d'une autre
				classe, le constructeur de la classe enfant peut explicitement appeler le constructeur de la
				classe parent en utilisant <code>super()</code>.
			</li>
			<li class="fragment">
				<strong>Appel implicite</strong>: Si aucun constructeur n'est explicitement d√©fini dans une
				classe, Java fournit un constructeur par d√©faut qui initialise les variables d'instance avec
				des valeurs par d√©faut.
			</li>
			<li class="fragment">
				<strong>Chaque objet a un constructeur</strong>: Chaque objet en Java est cr√©√© en appelant
				un constructeur, que ce soit le constructeur par d√©faut fourni par Java ou un constructeur
				d√©fini par l'utilisateur.
			</li>
		</ul>
		<p class="fragment">
			En r√©sum√©, les constructeurs en Java sont des √©l√©ments essentiels pour initialiser les objets
			et peuvent √™tre utilis√©s pour fournir diff√©rentes mani√®res de cr√©er des instances d'une
			classe.
		</p>
	</div>
</Slide>
<Slide>
	<h3>La classe <code>Object</code></h3>
	<p>Toute classe d√©clar√©e h√©rite implicitement de la classe <code>Object</code></p>
	<p>Tout objet peut red√©finir une m√©thode <code>toString()</code></p>
	<Code
		>{`
import java.util.*;

public class Main {
	int car_no;
	
	Main(int car_no){
		this.car_no=car_no;
	}

	// Driver code
	public static void main(String args[])
	{
		Main s = new Main(16);

		// Below two statements are equivalent
		System.out.println(s.toString());
		System.out.println(s);
	}
}
`}
	</Code>
	<Code
		>{`
        Main@d716361
        Main@d716361
            `}</Code
	>
</Slide>

<Slide>
	<h3>La classe <code>Object</code></h3>
	<p>Toute classe d√©clar√©e h√©rite implicitement de la classe <code>Object</code></p>
	<p>Tout objet peut red√©finir une m√©thode <code>toString()</code></p>

			<Code lines="10-12"
				>{`
            import java.util.*;

            public class Main {
                int car_no;
                
                Main(int car_no){
                    this.car_no=car_no;
                }
                // Overriding the toString()
                public String toString() {
                    return "Nombre de voitures : "+ car_no;
                }
                // Driver code
                public static void main(String args[])
                {
                    Main s = new Main(16);
                    System.out.println(s);
                }
            }
            `}</Code
			>
		<Code>{`Nombre de voitures : 16`}</Code></Slide
>
<Slide>
	<h3>La classe <code>Object</code></h3>
	<p>Toute classe d√©clar√©e h√©rite implicitement de la classe <code>Object</code></p>
	
	<p>Tout objet peut red√©finir une m√©thode <code>compareTo()</code></p>
	
	<Code lines
		>{`
		// Overriding compareTo() method
    @Override public int compareTo(GFG o)
    {
        if (this.age > o.age) {
 
            // if current object is greater,then return 1
            return 1;
        }
        else if (this.age < o.age) {
 
            // if current object is greater,then return -1
            return -1;
        }
        else {
 
            // if current object is equal to o,then return 0
            return 0;
        }
    }`}</Code
	>
</Slide>
<Slide>
	<h3>La classe <code>Object</code></h3>
	<p>Toute classe d√©clar√©e h√©rite implicitement de la classe <code>Object</code></p>
	<p>Tout objet peut red√©finir une m√©thode <code>equals()</code></p>
	
	<Code lines="12-32"
		>{`
		class Complex {
		 
		 private double re, im;
		
		 public Complex(double re, double im) {
			 this.re = re;
			 this.im = im;
		 }
		
		 // Overriding equals() to compare two Complex objects
		 @Override
		 public boolean equals(Object o) {
		
			 // If the object is compared with itself then return true  
			 if (o == this) {
				 return true;
			 }
		
			 /* Check if o is an instance of Complex or not
			   "null instanceof [type]" also returns false */
			 if (!(o instanceof Complex)) {
				 return false;
			 }
			  
			 // typecast o to Complex so that we can compare data members 
			 Complex c = (Complex) o;
			  
			 // Compare the data members and return accordingly 
			 return Double.compare(re, c.re) == 0
					 && Double.compare(im, c.im) == 0;
		 }
		}`}</Code
	>
</Slide>
